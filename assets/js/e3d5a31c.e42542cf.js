"use strict";(self.webpackChunkhades_2_mod_wiki=self.webpackChunkhades_2_mod_wiki||[]).push([[75850],{60528:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"h2m-docs/tables/rom.memory","title":"Table: rom.memory","description":"Table containing helper functions related to process memory.","source":"@site/docs/h2m-docs/tables/rom.memory.md","sourceDirName":"h2m-docs/tables","slug":"/h2m-docs/tables/rom.memory","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.memory","draft":false,"unlisted":false,"editUrl":"https://github.com/sgg-modding/hades2modwiki/tree/main/docs/h2m-docs/tables/rom.memory.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Table: rom.lpeg","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.lpeg"},"next":{"title":"Table: rom.mime","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.mime"}}');var s=r(74848),l=r(28453);const a={},i="Table: rom.memory",o={},c=[{value:"Functions (12)",id:"functions-12",level:2},{value:"<code>get_module_base_address(module_name (optional))</code>",id:"get_module_base_addressmodule_name-optional",level:3},{value:"<code>scan_pattern_from_module(module_name, pattern)</code>",id:"scan_pattern_from_modulemodule_name-pattern",level:3},{value:"<code>scan_pattern(pattern)</code>",id:"scan_patternpattern",level:3},{value:"<code>allocate(size)</code>",id:"allocatesize",level:3},{value:"<code>free(ptr)</code>",id:"freeptr",level:3},{value:"<code>dynamic_hook(hook_name, return_type, param_types, target_func_ptr, callbacks)</code>",id:"dynamic_hookhook_name-return_type-param_types-target_func_ptr-callbacks",level:3},{value:"<code>dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, target_func_ptr, mid_callback)</code>",id:"dynamic_hook_midhook_name-param_captures_targets-param_captures_types-stack_restore_offset-target_func_ptr-mid_callback",level:3},{value:"<code>dynamic_hook_enable(identifier)</code>",id:"dynamic_hook_enableidentifier",level:3},{value:"<code>dynamic_hook_disable(identifier)</code>",id:"dynamic_hook_disableidentifier",level:3},{value:"<code>dynamic_call(return_type, param_types, target_func_ptr)</code>",id:"dynamic_callreturn_type-param_types-target_func_ptr",level:3},{value:"<code>resolve_pointer_to_type(target_address, target_type)</code>",id:"resolve_pointer_to_typetarget_address-target_type",level:3},{value:"<code>get_usertype_pointer(usertype_object)</code>",id:"get_usertype_pointerusertype_object",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"table-rommemory",children:"Table: rom.memory"})}),"\n",(0,s.jsx)(n.p,{children:"Table containing helper functions related to process memory."}),"\n",(0,s.jsx)(n.h2,{id:"functions-12",children:"Functions (12)"}),"\n",(0,s.jsx)(n.h3,{id:"get_module_base_addressmodule_name-optional",children:(0,s.jsx)(n.code,{children:"get_module_base_address(module_name (optional))"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns the base address of a specified module within the current process. Returns a pointer",":is_null","() == true pointer otherwise."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module_name (optional)"}),' (string): The name of the module for which the base address is to be retrieved. Example: "ntdll.dll". If not provided, the API resolves this to the current targeted main module name automatically.']}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": A pointer to the found address."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"pointer = rom.memory.get_module_base_address(module_name (optional))\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scan_pattern_from_modulemodule_name-pattern",children:(0,s.jsx)(n.code,{children:"scan_pattern_from_module(module_name, pattern)"})}),"\n",(0,s.jsxs)(n.p,{children:["Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer",":is_null","() == true pointer otherwise."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module_name"}),' (string): module name. Example: "ntdll.dll"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pattern"})," (string): byte pattern (IDA format)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": A pointer to the found address."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"pointer = rom.memory.scan_pattern_from_module(module_name, pattern)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scan_patternpattern",children:(0,s.jsx)(n.code,{children:"scan_pattern(pattern)"})}),"\n",(0,s.jsxs)(n.p,{children:["Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer",":is_null","() == true pointer otherwise."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pattern"})," (string): byte pattern (IDA format)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": A pointer to the found address."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"pointer = rom.memory.scan_pattern(pattern)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"allocatesize",children:(0,s.jsx)(n.code,{children:"allocate(size)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"size"})," (integer): The number of bytes to allocate on the heap."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pointer"}),": A pointer to the newly allocated memory."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"pointer = rom.memory.allocate(size)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"freeptr",children:(0,s.jsx)(n.code,{children:"free(ptr)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ptr"})," (pointer): The pointer that must be freed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"rom.memory.free(ptr)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic_hookhook_name-return_type-param_types-target_func_ptr-callbacks",children:(0,s.jsx)(n.code,{children:"dynamic_hook(hook_name, return_type, param_types, target_func_ptr, callbacks)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local ptr = memory.scan_pattern("some ida sig")\n-- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\nrom.memory.dynamic_hook("test_hook", "float", {"const char*"}, ptr,\n{function(ret_val, str)\n\n     --str:set("replaced str")\n     ret_val:set(69.69)\n     log.info("pre callback from lua", ret_val:get(), str:get())\n\n     -- false for skipping the original function call\n     return false\nend,\nfunction(ret_val, str)\n     log.info("post callback from lua 1", ret_val:get(), str:get())\n     ret_val:set(79.69)\n     log.info("post callback from lua 2", ret_val:get(), str:get())\nend})\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hook_name"})," (string): The name of the hook."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"return_type"})," (string): Type of the return value of the detoured function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"param_types"})," (table","<","string",">","): Types of the parameters of the detoured function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to detour."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"callbacks"})," (table","<","function",">","): Table first element (can be nil): Pre function callback, lua function that will be called before the original function is about to be called. Pre function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> Returns true or false (boolean) depending on whether you want the original function to be called. Table second element (can be nil): function that will be called after the original function. Post function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> No return value."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"number"}),": Unique identifier for later disabling / enabling the hook on the fly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"number = rom.memory.dynamic_hook(hook_name, return_type, param_types, target_func_ptr, callbacks)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic_hook_midhook_name-param_captures_targets-param_captures_types-stack_restore_offset-target_func_ptr-mid_callback",children:(0,s.jsx)(n.code,{children:"dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, target_func_ptr, mid_callback)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'local ptr = memory.scan_pattern("some ida sig")\ngm.dynamic_hook_mid("test_hook", {"rax", "rcx", "[rcx+rdx*4+11]"}, {"int", "RValue*", "int"}, 0, ptr, function(args)\n     log.info("trigger", args[1]:get(), args[2].value, args[3]:set(1))\n     return ptr:add(246)\nend)\n'})}),"\n",(0,s.jsx)(n.p,{children:"But scan_pattern may be affected by the other hooks."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hook_name"})," (string): The name of the hook."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"param_captures_targets"})," (table","<","string",">","): Addresses of the parameters which you want to capture."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"param_captures_types"})," (table","<","string",">","): Types of the parameters which you want to capture."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stack_restore_offset"})," (int): An offset used to restore stack, only need when you want to customize the jump location."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to detour."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mid_callback"})," (function): The function that will be called when the program reaches the position. The callback must match the following signature: ( args (can be a value_wrapper, or a lua usertype directly, depending if you used ",(0,s.jsx)(n.code,{children:"add_type_info_from_string"})," through some c++ code and exposed it to the lua vm) ) -> Returns memory.pointer if you want to customize the jump location. Be careful when customizing the jump location, you need to restore the registers and the stack before the jump."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"number"}),": Unique identifier for later disabling / enabling the hook on the fly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"number = rom.memory.dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, target_func_ptr, mid_callback)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic_hook_enableidentifier",children:(0,s.jsx)(n.code,{children:"dynamic_hook_enable(identifier)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"identifier"})," (number): The identifier returned by the ",(0,s.jsx)(n.code,{children:"dynamic_hook"})," family functions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"rom.memory.dynamic_hook_enable(identifier)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic_hook_disableidentifier",children:(0,s.jsx)(n.code,{children:"dynamic_hook_disable(identifier)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"identifier"})," (number): The identifier returned by the ",(0,s.jsx)(n.code,{children:"dynamic_hook"})," family functions."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"rom.memory.dynamic_hook_disable(identifier)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic_callreturn_type-param_types-target_func_ptr",children:(0,s.jsx)(n.code,{children:"dynamic_call(return_type, param_types, target_func_ptr)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'-- the sig in this example leads to an implementation of memcpy_s\nlocal ptr = memory.scan_pattern("48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 20 49 8B D9 49 8B F0 48 8B FA")\nif ptr:is_valid() then\n     local dest_size = 8\n     local dest_ptr = memory.allocate(dest_size)\n     dest_ptr:set_qword(0)\n\n     local src_size = 8\n     local src_ptr = memory.allocate(src_size)\n     src_ptr:set_qword(123)\n\n     -- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\n     local func_to_call_test_global_name = rom.memory.dynamic_call("int", {"void*", "uint64_t", "void*", "uint64_t"}, ptr)\n     -- print zero.\n     log.info(dest_ptr:get_qword())\n     -- note: don\'t pass memory.pointer objects directly when you call the function, but use get_address() instead.\n     local call_res_test = _G[func_to_call_test_global_name](dest_ptr:get_address(), dest_size, src_ptr:get_address(), src_size)\n     -- print 123.\n     log.info(dest_ptr:get_qword())\nend\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"return_type"})," (string): Type of the return value of the function to call."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"param_types"})," (table","<","string",">","): Types of the parameters of the function to call."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to call."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"string"}),": Key name of the function that you can now call from lua."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"string = rom.memory.dynamic_call(return_type, param_types, target_func_ptr)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"resolve_pointer_to_typetarget_address-target_type",children:(0,s.jsx)(n.code,{children:"resolve_pointer_to_type(target_address, target_type)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'memory.dynamic_hook("test", "RValue*", {"CInstance*","CInstance*","RValue*","int","RValue**"},\nptr, function (ret_val, skill, player, result, arg_num, args_ptr)\n     log.info(rom.memory.resolve_pointer_to_type(memory.get_usertype_pointer(skill), "YYObjectBase*").skill_id)\n     log.info(rom.memory.resolve_pointer_to_type(args_ptr:deref():get_address(), "RValue*").value)\n     log.info(rom.memory.resolve_pointer_to_type(args_ptr:add(8):deref():get_address(), "RValue*").value)\nend)\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_address"})," (number): The object target as a lua number."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target_type"})," (string): Target type (must be a pointer type)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lua usertype."}),":"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"lua usertype. = rom.memory.resolve_pointer_to_type(target_address, target_type)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"get_usertype_pointerusertype_object",children:(0,s.jsx)(n.code,{children:"get_usertype_pointer(usertype_object)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"usertype_object"})," (any_usertype): A lua usertype instance."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"number"}),": The object address as a lua number."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"number = rom.memory.get_usertype_pointer(usertype_object)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(96540);const s={},l=t.createContext(s);function a(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);