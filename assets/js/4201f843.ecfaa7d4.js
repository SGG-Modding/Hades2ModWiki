"use strict";(self.webpackChunkhades_2_mod_wiki=self.webpackChunkhades_2_mod_wiki||[]).push([[9965],{24908:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"h2m-docs/tables/definitions/rom.inputs","title":"rom.inputs.lua","description":"","source":"@site/docs/h2m-docs/tables/definitions/rom.inputs.md","sourceDirName":"h2m-docs/tables/definitions","slug":"/h2m-docs/tables/definitions/rom.inputs","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.inputs","draft":false,"unlisted":false,"editUrl":"https://github.com/sgg-modding/hades2modwiki/tree/main/docs/h2m-docs/tables/definitions/rom.inputs.md","tags":[],"version":"current","frontMatter":{"title":"rom.inputs.lua"},"sidebar":"tutorialSidebar","previous":{"title":"rom.gui.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.gui"},"next":{"title":"rom.log.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.log"}}');var i=t(74848),o=t(28453);const a={title:"rom.inputs.lua"},r=void 0,d={},l=[];function u(e){const n={code:"code",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'---@meta inputs\n\n---@class (exact) rom.inputs\n\n-- The parameters must be inside a table. Check how the vanilla game does it through `OnKeyPressed`.\n--For every possible keys, please refer to [this map](https://github.com/SGG-Modding/Hell2Modding/blob/6d1cb8ed8870a401ac1cefd599bf2ae3a270d949/src/lua_extensions/bindings/hades/inputs.cpp#L204-L298)\n--\n--**Example Usage:**\n--```lua\n--local handle = rom.inputs.on_key_pressed{"Ctrl X", Name = "Testing key 2", function()\n--     print("hello there")\n--end}\n--```\n---@param [1] string The key binding string representing the keys that, when pressed, will trigger the callback function. The format used is the one used by the vanilla game, please check the vanilla scripts using "OnKeyPressed".\n---@param [2] function The function to be called when the specified keybind is pressed.\n---@param Name string Optional. The name linked to this keybind, used in the GUI to help the user know what it corresponds to.\n---@return table # Returns a handle to use, in case you want to remove this specific keybind.\nfunction inputs.on_key_pressed([1], [2], Name) end\n\n-- Remove a keybind previously added through `on_key_pressed`.\n---@param handle table The handle that was returned to you from the on_key_pressed call.\nfunction inputs.remove_on_key_pressed(handle) end\n\n-- Allows game input to be processed even when the GUI layer is active. This is useful for scenarios where you need the game to remain responsive to player actions or on key presses callbacks despite overlay interfaces.\n---@param new_value bool Optional. Set the backing field to the passed new value.\nfunction inputs.let_game_input_go_through_gui_layer(new_value) end\n\n-- Enables the default debug key bindings used in the vanilla game.\n---@param new_value bool Optional. Set the backing field to the passed new value.\nfunction inputs.enable_vanilla_debug_keybinds(new_value) end\n\n'})})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);