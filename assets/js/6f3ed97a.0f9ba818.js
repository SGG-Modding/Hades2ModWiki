"use strict";(self.webpackChunkhades_2_mod_wiki=self.webpackChunkhades_2_mod_wiki||[]).push([[44994],{24094:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"h2m-docs/tables/definitions/rom.memory","title":"rom.memory.lua","description":"","source":"@site/docs/h2m-docs/tables/definitions/rom.memory.md","sourceDirName":"h2m-docs/tables/definitions","slug":"/h2m-docs/tables/definitions/rom.memory","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.memory","draft":false,"unlisted":false,"editUrl":"https://github.com/sgg-modding/hades2modwiki/tree/main/docs/h2m-docs/tables/definitions/rom.memory.md","tags":[],"version":"current","frontMatter":{"title":"rom.memory.lua"},"sidebar":"tutorialSidebar","previous":{"title":"rom.lpeg.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.lpeg"},"next":{"title":"rom.mime.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.mime"}}');var a=r(74848),o=r(28453);const i={title:"rom.memory.lua"},s=void 0,l={},m=[];function u(e){const t={code:"code",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'---@meta memory\r\n\r\n-- Table containing helper functions related to process memory.\r\n---@class (exact) rom.memory\r\n\r\n-- Returns the base address of a specified module within the current process. Returns a pointer:is_null() == true pointer otherwise.\r\n---@param module_name (optional) string The name of the module for which the base address is to be retrieved. Example: "ntdll.dll". If not provided, the API resolves this to the current targeted main module name automatically.\r\n---@return pointer # A pointer to the found address.\r\nfunction memory.get_module_base_address(module_name (optional)) end\r\n\r\n-- Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer:is_null() == true pointer otherwise.\r\n---@param module_name string module name. Example: "ntdll.dll"\r\n---@param pattern string byte pattern (IDA format)\r\n---@return pointer # A pointer to the found address.\r\nfunction memory.scan_pattern_from_module(module_name, pattern) end\r\n\r\n-- Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer:is_null() == true pointer otherwise.\r\n---@param pattern string byte pattern (IDA format)\r\n---@return pointer # A pointer to the found address.\r\nfunction memory.scan_pattern(pattern) end\r\n\r\n---@param size integer The number of bytes to allocate on the heap.\r\n---@return pointer # A pointer to the newly allocated memory.\r\nfunction memory.allocate(size) end\r\n\r\n---@param ptr pointer The pointer that must be freed.\r\nfunction memory.free(ptr) end\r\n\r\n-- **Example Usage:**\r\n--```lua\r\n--local ptr = memory.scan_pattern("some ida sig")\r\n---- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\r\n--rom.memory.dynamic_hook("test_hook", "float", {"const char*"}, ptr,\r\n--{function(ret_val, str)\r\n--\r\n--     --str:set("replaced str")\r\n--     ret_val:set(69.69)\r\n--     log.info("pre callback from lua", ret_val:get(), str:get())\r\n--\r\n--     -- false for skipping the original function call\r\n--     return false\r\n--end,\r\n--function(ret_val, str)\r\n--     log.info("post callback from lua 1", ret_val:get(), str:get())\r\n--     ret_val:set(79.69)\r\n--     log.info("post callback from lua 2", ret_val:get(), str:get())\r\n--end})\r\n--```\r\n---@param hook_name string The name of the hook.\r\n---@param return_type string Type of the return value of the detoured function.\r\n---@param param_types table{\'<\'}string> Types of the parameters of the detoured function.\r\n---@param target_func_ptr memory.pointer The pointer to the function to detour.\r\n---@param callbacks table{\'<\'}function> Table first element (can be nil): Pre function callback, lua function that will be called before the original function is about to be called. Pre function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> Returns true or false (boolean) depending on whether you want the original function to be called. Table second element (can be nil): function that will be called after the original function. Post function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> No return value.\r\n---@return number # Unique identifier for later disabling / enabling the hook on the fly.\r\nfunction memory.dynamic_hook(hook_name, return_type, param_types, target_func_ptr, callbacks) end\r\n\r\n-- **Example Usage:**\r\n--```lua\r\n--local ptr = memory.scan_pattern("some ida sig")\r\n--gm.dynamic_hook_mid("test_hook", {"rax", "rcx", "[rcx+rdx*4+11]"}, {"int", "RValue*", "int"}, 0, ptr, function(args)\r\n--     log.info("trigger", args[1]:get(), args[2].value, args[3]:set(1))\r\n--     return ptr:add(246)\r\n--end)\r\n--```\r\n--But scan_pattern may be affected by the other hooks.\r\n---@param hook_name string The name of the hook.\r\n---@param param_captures_targets table{\'<\'}string> Addresses of the parameters which you want to capture.\r\n---@param param_captures_types table{\'<\'}string> Types of the parameters which you want to capture.\r\n---@param stack_restore_offset int An offset used to restore stack, only need when you want to customize the jump location.\r\n---@param target_func_ptr memory.pointer The pointer to the function to detour.\r\n---@param mid_callback function The function that will be called when the program reaches the position. The callback must match the following signature: ( args (can be a value_wrapper, or a lua usertype directly, depending if you used `add_type_info_from_string` through some c++ code and exposed it to the lua vm) ) -> Returns memory.pointer if you want to customize the jump location. Be careful when customizing the jump location, you need to restore the registers and the stack before the jump.\r\n---@return number # Unique identifier for later disabling / enabling the hook on the fly.\r\nfunction memory.dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, target_func_ptr, mid_callback) end\r\n\r\n---@param identifier number The identifier returned by the `dynamic_hook` family functions.\r\nfunction memory.dynamic_hook_enable(identifier) end\r\n\r\n---@param identifier number The identifier returned by the `dynamic_hook` family functions.\r\nfunction memory.dynamic_hook_disable(identifier) end\r\n\r\n-- **Example Usage:**\r\n--```lua\r\n---- the sig in this example leads to an implementation of memcpy_s\r\n--local ptr = memory.scan_pattern("48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 20 49 8B D9 49 8B F0 48 8B FA")\r\n--if ptr:is_valid() then\r\n--     local dest_size = 8\r\n--     local dest_ptr = memory.allocate(dest_size)\r\n--     dest_ptr:set_qword(0)\r\n--\r\n--     local src_size = 8\r\n--     local src_ptr = memory.allocate(src_size)\r\n--     src_ptr:set_qword(123)\r\n--\r\n--     -- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\r\n--     local func_to_call_test_global_name = rom.memory.dynamic_call("int", {"void*", "uint64_t", "void*", "uint64_t"}, ptr)\r\n--     -- print zero.\r\n--     log.info(dest_ptr:get_qword())\r\n--     -- note: don\'t pass memory.pointer objects directly when you call the function, but use get_address() instead.\r\n--     local call_res_test = _G[func_to_call_test_global_name](dest_ptr:get_address(), dest_size, src_ptr:get_address(), src_size)\r\n--     -- print 123.\r\n--     log.info(dest_ptr:get_qword())\r\n--end\r\n--```\r\n---@param return_type string Type of the return value of the function to call.\r\n---@param param_types table{\'<\'}string> Types of the parameters of the function to call.\r\n---@param target_func_ptr memory.pointer The pointer to the function to call.\r\n---@return string # Key name of the function that you can now call from lua.\r\nfunction memory.dynamic_call(return_type, param_types, target_func_ptr) end\r\n\r\n-- **Example Usage:**\r\n--```lua\r\n--memory.dynamic_hook("test", "RValue*", {"CInstance*","CInstance*","RValue*","int","RValue**"},\r\n--ptr, function (ret_val, skill, player, result, arg_num, args_ptr)\r\n--     log.info(rom.memory.resolve_pointer_to_type(memory.get_usertype_pointer(skill), "YYObjectBase*").skill_id)\r\n--     log.info(rom.memory.resolve_pointer_to_type(args_ptr:deref():get_address(), "RValue*").value)\r\n--     log.info(rom.memory.resolve_pointer_to_type(args_ptr:add(8):deref():get_address(), "RValue*").value)\r\n--end)\r\n--```\r\n---@param target_address number The object target as a lua number.\r\n---@param target_type string Target type (must be a pointer type).\r\n---@return lua usertype. # \r\nfunction memory.resolve_pointer_to_type(target_address, target_type) end\r\n\r\n---@param usertype_object any_usertype A lua usertype instance.\r\n---@return number # The object address as a lua number.\r\nfunction memory.get_usertype_pointer(usertype_object) end\r\n\n'})})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var n=r(96540);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);