"use strict";(self.webpackChunkhades_2_mod_wiki=self.webpackChunkhades_2_mod_wiki||[]).push([[75850],{60528:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>i});const t=JSON.parse('{"id":"h2m-docs/tables/rom.memory","title":"Table: rom.memory","description":"Table containing helper functions related to process memory.","source":"@site/docs/h2m-docs/tables/rom.memory.md","sourceDirName":"h2m-docs/tables","slug":"/h2m-docs/tables/rom.memory","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.memory","draft":false,"unlisted":false,"editUrl":"https://github.com/sgg-modding/hades2modwiki/tree/main/docs/h2m-docs/tables/rom.memory.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Table: rom.lz4","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.lz4"},"next":{"title":"Table: rom.mime","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/rom.mime"}}');var s=n(74848),a=n(28453);const l={},o="Table: rom.memory",c={},i=[{value:"Functions (8)",id:"functions-8",level:2},{value:"<code>scan_pattern(pattern)</code>",id:"scan_patternpattern",level:3},{value:"<code>allocate(size)</code>",id:"allocatesize",level:3},{value:"<code>free(ptr)</code>",id:"freeptr",level:3},{value:"<code>dynamic_hook(hook_name, return_type, param_types, target_func_ptr, pre_callback, post_callback)</code>",id:"dynamic_hookhook_name-return_type-param_types-target_func_ptr-pre_callback-post_callback",level:3},{value:"<code>dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, param_restores, target_func_ptr, mid_callback)</code>",id:"dynamic_hook_midhook_name-param_captures_targets-param_captures_types-stack_restore_offset-param_restores-target_func_ptr-mid_callback",level:3},{value:"<code>dynamic_call(return_type, param_types, target_func_ptr)</code>",id:"dynamic_callreturn_type-param_types-target_func_ptr",level:3},{value:"<code>resolve_pointer_to_type(target_address, target_type)</code>",id:"resolve_pointer_to_typetarget_address-target_type",level:3},{value:"<code>get_usertype_pointer(usertype_object)</code>",id:"get_usertype_pointerusertype_object",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"table-rommemory",children:"Table: rom.memory"})}),"\n",(0,s.jsx)(r.p,{children:"Table containing helper functions related to process memory."}),"\n",(0,s.jsx)(r.h2,{id:"functions-8",children:"Functions (8)"}),"\n",(0,s.jsx)(r.h3,{id:"scan_patternpattern",children:(0,s.jsx)(r.code,{children:"scan_pattern(pattern)"})}),"\n",(0,s.jsx)(r.p,{children:"Scans the specified memory pattern within the target main module and returns a pointer to the found address."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"pattern"})," (string): byte pattern (IDA format)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"pointer"}),": A pointer to the found address."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"pointer = rom.memory.scan_pattern(pattern)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"allocatesize",children:(0,s.jsx)(r.code,{children:"allocate(size)"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"size"})," (integer): The number of bytes to allocate on the heap."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"pointer"}),": A pointer to the newly allocated memory."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"pointer = rom.memory.allocate(size)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"freeptr",children:(0,s.jsx)(r.code,{children:"free(ptr)"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ptr"})," (pointer): The pointer that must be freed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"rom.memory.free(ptr)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"dynamic_hookhook_name-return_type-param_types-target_func_ptr-pre_callback-post_callback",children:(0,s.jsx)(r.code,{children:"dynamic_hook(hook_name, return_type, param_types, target_func_ptr, pre_callback, post_callback)"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local ptr = memory.scan_pattern("some ida sig")\r\n-- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\r\nrom.memory.dynamic_hook("test_hook", "float", {"const char*"}, ptr,\r\nfunction(ret_val, str)\r\n\r\n     --str:set("replaced str")\r\n     ret_val:set(69.69)\r\n     log.info("pre callback from lua", ret_val:get(), str:get())\r\n\r\n     -- false for skipping the original function call\r\n     return false\r\nend,\r\nfunction(ret_val, str)\r\n     log.info("post callback from lua 1", ret_val:get(), str:get())\r\n     ret_val:set(79.69)\r\n     log.info("post callback from lua 2", ret_val:get(), str:get())\r\nend)\n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"hook_name"})," (string): The name of the hook."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"return_type"})," (string): Type of the return value of the detoured function."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"param_types"})," (table","<","string",">","): Types of the parameters of the detoured function."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to detour."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"pre_callback"})," (function): The function that will be called before the original function is about to be called. The callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> Returns true or false (boolean) depending on whether you want the original function to be called."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"post_callback"})," (function): The function that will be called after the original function is called (or just after the pre callback is called, if the original function was skipped). The callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> void"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"rom.memory.dynamic_hook(hook_name, return_type, param_types, target_func_ptr, pre_callback, post_callback)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"dynamic_hook_midhook_name-param_captures_targets-param_captures_types-stack_restore_offset-param_restores-target_func_ptr-mid_callback",children:(0,s.jsx)(r.code,{children:"dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, param_restores, target_func_ptr, mid_callback)"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local ptr = memory.scan_pattern("some ida sig")\r\ngm.dynamic_hook_mid("test_hook", {"rax", "rcx", "[rcx+rdx*4+11]"}, {"int", "RValue*", "int"}, 0, {}, ptr, function(args)\r\n     log.info("trigger", args[1]:get(), args[2].value, args[3]:set(1))\r\nend)\n'})}),"\n",(0,s.jsx)(r.p,{children:"But scan_pattern may be affected by the other hooks."}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"hook_name"})," (string): The name of the hook."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"param_captures_targets"})," (table","<","string",">","): Addresses of the parameters which you want to capture."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"param_captures_types"})," (table","<","string",">","): Types of the parameters which you want to capture."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"stack_restore_offset"})," (int): An offset used to restore stack, only need when you want to interrupt the function."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"param_restores"})," (table","<","string, string",">","): Restore targets and restore sources used to restore function, only need when you want to interrupt the function."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to detour."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"mid_callback"})," (function): The function that will be called when the program reaches the position. The callback must match the following signature: ( args (can be a value_wrapper, or a lua usertype directly, depending if you used ",(0,s.jsx)(r.code,{children:"add_type_info_from_string"})," through some c++ code and exposed it to the lua vm) ) -> Returns false (boolean) if you want to interrupt the function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"rom.memory.dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, param_restores, target_func_ptr, mid_callback)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"dynamic_callreturn_type-param_types-target_func_ptr",children:(0,s.jsx)(r.code,{children:"dynamic_call(return_type, param_types, target_func_ptr)"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'-- the sig in this example leads to an implementation of memcpy_s\r\nlocal ptr = memory.scan_pattern("48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 20 49 8B D9 49 8B F0 48 8B FA")\r\nif ptr:is_valid() then\r\n     local dest_size = 8\r\n     local dest_ptr = memory.allocate(dest_size)\r\n     dest_ptr:set_qword(0)\r\n\r\n     local src_size = 8\r\n     local src_ptr = memory.allocate(src_size)\r\n     src_ptr:set_qword(123)\r\n\r\n     -- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\r\n     local func_to_call_test_global_name = rom.memory.dynamic_call("int", {"void*", "uint64_t", "void*", "uint64_t"}, ptr)\r\n     -- print zero.\r\n     log.info(dest_ptr:get_qword())\r\n     -- note: don\'t pass memory.pointer objects directly when you call the function, but use get_address() instead.\r\n     local call_res_test = _G[func_to_call_test_global_name](dest_ptr:get_address(), dest_size, src_ptr:get_address(), src_size)\r\n     -- print 123.\r\n     log.info(dest_ptr:get_qword())\r\nend\n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"return_type"})," (string): Type of the return value of the function to call."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"param_types"})," (table","<","string",">","): Types of the parameters of the function to call."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"target_func_ptr"})," (memory.pointer): The pointer to the function to call."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"string"}),": Key name of the function that you can now call from lua."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"string = rom.memory.dynamic_call(return_type, param_types, target_func_ptr)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"resolve_pointer_to_typetarget_address-target_type",children:(0,s.jsx)(r.code,{children:"resolve_pointer_to_type(target_address, target_type)"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'memory.dynamic_hook("test", "RValue*", {"CInstance*","CInstance*","RValue*","int","RValue**"},\r\nptr, function (ret_val, skill, player, result, arg_num, args_ptr)\r\n     log.info(rom.memory.resolve_pointer_to_type(memory.get_usertype_pointer(skill), "YYObjectBase*").skill_id)\r\n     log.info(rom.memory.resolve_pointer_to_type(args_ptr:deref():get_address(), "RValue*").value)\r\n     log.info(rom.memory.resolve_pointer_to_type(args_ptr:add(8):deref():get_address(), "RValue*").value)\r\nend)\n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"target_address"})," (number): The object target as a lua number."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"target_type"})," (string): Target type (must be a pointer type)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"lua usertype."}),":"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"lua usertype. = rom.memory.resolve_pointer_to_type(target_address, target_type)\n"})}),"\n",(0,s.jsx)(r.h3,{id:"get_usertype_pointerusertype_object",children:(0,s.jsx)(r.code,{children:"get_usertype_pointer(usertype_object)"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"usertype_object"})," (any_usertype): A lua usertype instance."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"number"}),": The object address as a lua number."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Example Usage:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"number = rom.memory.get_usertype_pointer(usertype_object)\n"})})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>o});var t=n(96540);const s={},a=t.createContext(s);function l(e){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);