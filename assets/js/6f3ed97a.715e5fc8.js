"use strict";(self.webpackChunkhades_2_mod_wiki=self.webpackChunkhades_2_mod_wiki||[]).push([[44994],{24094:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"h2m-docs/tables/definitions/rom.memory","title":"rom.memory.lua","description":"","source":"@site/docs/h2m-docs/tables/definitions/rom.memory.md","sourceDirName":"h2m-docs/tables/definitions","slug":"/h2m-docs/tables/definitions/rom.memory","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.memory","draft":false,"unlisted":false,"editUrl":"https://github.com/sgg-modding/hades2modwiki/tree/main/docs/h2m-docs/tables/definitions/rom.memory.md","tags":[],"version":"current","frontMatter":{"title":"rom.memory.lua"},"sidebar":"tutorialSidebar","previous":{"title":"rom.lpeg.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.lpeg"},"next":{"title":"rom.mime.lua","permalink":"/Hades2ModWiki/docs/h2m-docs/tables/definitions/rom.mime"}}');var a=n(74848),o=n(28453);const i={title:"rom.memory.lua"},s=void 0,l={},m=[];function u(e){const t={code:"code",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-lua",children:'---@meta memory\n\n-- Table containing helper functions related to process memory.\n---@class (exact) rom.memory\n\n-- Returns the base address of a specified module within the current process. Returns a pointer:is_null() == true pointer otherwise.\n---@param module_name (optional) string The name of the module for which the base address is to be retrieved. Example: "ntdll.dll". If not provided, the API resolves this to the current targeted main module name automatically.\n---@return pointer # A pointer to the found address.\nfunction memory.get_module_base_address(module_name (optional)) end\n\n-- Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer:is_null() == true pointer otherwise.\n---@param module_name string module name. Example: "ntdll.dll"\n---@param pattern string byte pattern (IDA format)\n---@return pointer # A pointer to the found address.\nfunction memory.scan_pattern_from_module(module_name, pattern) end\n\n-- Scans the specified memory pattern within the target main module and returns a pointer to the found address. Returns a pointer:is_null() == true pointer otherwise.\n---@param pattern string byte pattern (IDA format)\n---@return pointer # A pointer to the found address.\nfunction memory.scan_pattern(pattern) end\n\n---@param size integer The number of bytes to allocate on the heap.\n---@return pointer # A pointer to the newly allocated memory.\nfunction memory.allocate(size) end\n\n---@param ptr pointer The pointer that must be freed.\nfunction memory.free(ptr) end\n\n-- **Example Usage:**\n--```lua\n--local ptr = memory.scan_pattern("some ida sig")\n---- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\n--rom.memory.dynamic_hook("test_hook", "float", {"const char*"}, ptr,\n--{function(ret_val, str)\n--\n--     --str:set("replaced str")\n--     ret_val:set(69.69)\n--     log.info("pre callback from lua", ret_val:get(), str:get())\n--\n--     -- false for skipping the original function call\n--     return false\n--end,\n--function(ret_val, str)\n--     log.info("post callback from lua 1", ret_val:get(), str:get())\n--     ret_val:set(79.69)\n--     log.info("post callback from lua 2", ret_val:get(), str:get())\n--end})\n--```\n---@param hook_name string The name of the hook.\n---@param return_type string Type of the return value of the detoured function.\n---@param param_types table{\'<\'}string> Types of the parameters of the detoured function.\n---@param target_func_ptr memory.pointer The pointer to the function to detour.\n---@param callbacks table{\'<\'}function> Table first element (can be nil): Pre function callback, lua function that will be called before the original function is about to be called. Pre function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> Returns true or false (boolean) depending on whether you want the original function to be called. Table second element (can be nil): function that will be called after the original function. Post function callback must match the following signature: ( return_value (value_wrapper), arg1 (value_wrapper), arg2 (value_wrapper), ... ) -> No return value.\n---@return number # Unique identifier for later disabling / enabling the hook on the fly.\nfunction memory.dynamic_hook(hook_name, return_type, param_types, target_func_ptr, callbacks) end\n\n-- **Example Usage:**\n--```lua\n--local ptr = memory.scan_pattern("some ida sig")\n--gm.dynamic_hook_mid("test_hook", {"rax", "rcx", "[rcx+rdx*4+11]"}, {"int", "RValue*", "int"}, 0, ptr, function(args)\n--     log.info("trigger", args[1]:get(), args[2].value, args[3]:set(1))\n--     return ptr:add(246)\n--end)\n--```\n--But scan_pattern may be affected by the other hooks.\n---@param hook_name string The name of the hook.\n---@param param_captures_targets table{\'<\'}string> Addresses of the parameters which you want to capture.\n---@param param_captures_types table{\'<\'}string> Types of the parameters which you want to capture.\n---@param stack_restore_offset int An offset used to restore stack, only need when you want to customize the jump location.\n---@param target_func_ptr memory.pointer The pointer to the function to detour.\n---@param mid_callback function The function that will be called when the program reaches the position. The callback must match the following signature: ( args (can be a value_wrapper, or a lua usertype directly, depending if you used `add_type_info_from_string` through some c++ code and exposed it to the lua vm) ) -> Returns memory.pointer if you want to customize the jump location. Be careful when customizing the jump location, you need to restore the registers and the stack before the jump.\n---@return number # Unique identifier for later disabling / enabling the hook on the fly.\nfunction memory.dynamic_hook_mid(hook_name, param_captures_targets, param_captures_types, stack_restore_offset, target_func_ptr, mid_callback) end\n\n---@param identifier number The identifier returned by the `dynamic_hook` family functions.\nfunction memory.dynamic_hook_enable(identifier) end\n\n---@param identifier number The identifier returned by the `dynamic_hook` family functions.\nfunction memory.dynamic_hook_disable(identifier) end\n\n-- **Example Usage:**\n--```lua\n---- the sig in this example leads to an implementation of memcpy_s\n--local ptr = memory.scan_pattern("48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 20 49 8B D9 49 8B F0 48 8B FA")\n--if ptr:is_valid() then\n--     local dest_size = 8\n--     local dest_ptr = memory.allocate(dest_size)\n--     dest_ptr:set_qword(0)\n--\n--     local src_size = 8\n--     local src_ptr = memory.allocate(src_size)\n--     src_ptr:set_qword(123)\n--\n--     -- Check the implementation of the asmjit::TypeId get_type_id function if you are unsure what to use for return type / parameters types\n--     local func_to_call_test_global_name = rom.memory.dynamic_call("int", {"void*", "uint64_t", "void*", "uint64_t"}, ptr)\n--     -- print zero.\n--     log.info(dest_ptr:get_qword())\n--     -- note: don\'t pass memory.pointer objects directly when you call the function, but use get_address() instead.\n--     local call_res_test = _G[func_to_call_test_global_name](dest_ptr:get_address(), dest_size, src_ptr:get_address(), src_size)\n--     -- print 123.\n--     log.info(dest_ptr:get_qword())\n--end\n--```\n---@param return_type string Type of the return value of the function to call.\n---@param param_types table{\'<\'}string> Types of the parameters of the function to call.\n---@param target_func_ptr memory.pointer The pointer to the function to call.\n---@return string # Key name of the function that you can now call from lua.\nfunction memory.dynamic_call(return_type, param_types, target_func_ptr) end\n\n-- **Example Usage:**\n--```lua\n--memory.dynamic_hook("test", "RValue*", {"CInstance*","CInstance*","RValue*","int","RValue**"},\n--ptr, function (ret_val, skill, player, result, arg_num, args_ptr)\n--     log.info(rom.memory.resolve_pointer_to_type(memory.get_usertype_pointer(skill), "YYObjectBase*").skill_id)\n--     log.info(rom.memory.resolve_pointer_to_type(args_ptr:deref():get_address(), "RValue*").value)\n--     log.info(rom.memory.resolve_pointer_to_type(args_ptr:add(8):deref():get_address(), "RValue*").value)\n--end)\n--```\n---@param target_address number The object target as a lua number.\n---@param target_type string Target type (must be a pointer type).\n---@return lua usertype. # \nfunction memory.resolve_pointer_to_type(target_address, target_type) end\n\n---@param usertype_object any_usertype A lua usertype instance.\n---@return number # The object address as a lua number.\nfunction memory.get_usertype_pointer(usertype_object) end\n\n'})})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(96540);const a={},o=r.createContext(a);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);